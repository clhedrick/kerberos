/*
 * Mostly generated by rpcgen. However some of it was
 * taken from the upstream source for quota, which is GPL.
 * Thus the following:
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public License as
 *   published by the Free Software Foundation; either version 2 of
 *   the License, or (at your option) any later version.
 * Note that the original does not contain a copyright notice.
 */

#define _GNU_SOURCE
#include "rquota.h"
#include <stdio.h>
#include <mntent.h>
#include <stdlib.h>
#include <pwd.h>
#include <grp.h>
#include <string.h>
#include <regex.h>

// Rutgers start

#include <rpc/rpc.h>
#include <rpc/rpc_com.h>
// these are zfs things.
// zfs has to be on the system
#include <sys/nvpair.h>
#include <libnvpair.h>
#include <libzfs.h>

#define USRQUOTA  0             /* element used for user quotas */
#define GRPQUOTA  1             /* element used for group quotas */
#define PRJQUOTA  2             /* element used for project quotas */

// note: strlcpy and strlcat should be
// in libc but aren't. I think they come
// from one of the ZFS libraries

extern char nfs_pseudoroot[PATH_MAX];

// get mountpoint and uid
// input: args - union structure
//        pathname - buffer to copy path to, size PATH_MAX
// output: uid
//         path copied to pathname


/*                                                                                                                                                                                
 * Global unix authentication credentials.                                                                                                                                        
 */
extern struct authunix_parms *unix_cred;

int in_group(gid_t * gids, uint32_t len, gid_t gid)
{
        gid_t *gidsp = gids + len;

        while (gidsp > gids) {
	  if (*gids == gid)
	    return 1;
	  gids++;
	}

	return 0;
}

bool_t
checkcred(struct svc_req *rqstp, uid_t id, int type) {
  struct authunix_parms *unix_cred;

  switch (rqstp->rq_cred.oa_flavor) {
  case AUTH_UNIX:
    unix_cred = (struct authunix_parms *)rqstp->rq_clntcred;
    if (type == USRQUOTA && unix_cred->aup_uid && unix_cred->aup_uid != id)
      return 0;
    if (type == GRPQUOTA && unix_cred->aup_uid && unix_cred->aup_gid != id &&
	! in_group((gid_t *) unix_cred->aup_gids, unix_cred->aup_len, id))
      return 0;
    return 1;
  case AUTH_NULL:
    return 1;
  default:
    return 0;
  }
}

uid_t
getpath(getquota_args args, struct svc_req *rqstp, char *pathname, int *type) {
  uid_t id = args.gqa_uid;
  char *next;
  pathname[0] = '\0';

  *type = USRQUOTA;
  if (args.gqa_pathp[0] != '/')
    strlcpy(pathname, nfs_pseudoroot, PATH_MAX);
  strlcat(pathname, args.gqa_pathp, PATH_MAX);

  return id;
}

// differs only in argument type. for _2 versions

uid_t
getpath2(ext_getquota_args args, struct svc_req *rqstp, char *pathname, int *type) {
  uid_t id = args.gqa_id;
  char *next;
  pathname[0] = '\0';

  *type = args.gqa_type;
  if (args.gqa_pathp[0] != '/')
    strlcpy(pathname, nfs_pseudoroot, PATH_MAX);
  strlcat(pathname, args.gqa_pathp, PATH_MAX);

  return id;
}

// get one ZFS quota
// input: quota - type of quota, e.g. userused
//        propbuf - buffer to write name into
//        user - unix username
//        libh, zh - handles into zfs library
// output: quota as unsigned long
//        if it fails, return in *failed
//           if a failure happens proabably shouldn't try anymore

unsigned long
getquota(char *quota, char *propbuf, int propbuflen, char *user, libzfs_handle_t *libh, zfs_handle_t *zh, int *failed) {
  char *attr = NULL;
  unsigned long ret;

  asprintf(&attr, "%s@%s", quota, user);
  if (!attr) {
    *failed = 1;
    return 0L;
  }

  strcpy(propbuf, "0"); // in case no quota for this user                                                                                  
  if (zfs_prop_get_userquota(zh, attr, propbuf, propbuflen-1, 1) == 0)
    ret = atol(propbuf);
  else
    ret = 0L;

  free(attr);
  return ret;
}

// main code. sets up quotas for user in result structure
//  input: path - mount point
//         result - union struct where quotas go
//         id  - unix uid
//  output: boolean, did it work
//         quotas written into result struct

bool_t
rquotaproc_common(char *path, struct svc_req *rqstp, getquota_rslt *result, uid_t id, int type) {
	bool_t retval;
	FILE *mfile;
	struct mntent *m;
	struct mntent mntent;
	char mntbuf[4096];
	char *attr = NULL;
	struct passwd passwd;
	struct passwd *pwd = &passwd;
	struct passwd *rpwd = NULL;
	char pwdbuf[1024];
	struct group group;
	struct group *grp = &group;
	struct group *rgrp = NULL;
	char *name;
	libzfs_handle_t *libh = NULL;
	zfs_handle_t *zh = NULL;
	unsigned long currspace;
	unsigned long currfiles;
	unsigned long quotaspace;
	unsigned long quotafiles;		
	char propbuf[1024];
	int failed = 0;
	int matched = 0;
	char filesys[PATH_MAX];

	if (!checkcred(rqstp, id, type)) {
	  result->status = Q_EPERM;
	  return 1;
	}

	// given mount point find ZFS file system

	mfile = setmntent("/etc/mtab", "r");
	if (! mfile)
	  return 0;

	while (m = getmntent_r(mfile, &mntent, mntbuf, sizeof(mntbuf))) {
	  // we want the largest match for export
	  if (strcmp(m->mnt_type, "zfs") == 0 &&
	      strlen(m->mnt_dir) <= strlen(path) &&
	      strncmp(m->mnt_dir, path, strlen(m->mnt_dir)) == 0 &&
	      strlen(m->mnt_dir) > matched) {
	    matched = strlen(m->mnt_dir);
	    strlcpy(filesys, m->mnt_fsname, sizeof(filesys));
	  }
	}

	endmntent(mfile);
	
	// m->mnt_fsname is now the ZFS file system

	if (!matched)
	  return 0;
	
	// have UID from the RPC call. Need username

	if (type == USRQUOTA) {
	  if (getpwuid_r(id, pwd, pwdbuf, sizeof(pwdbuf), &rpwd) != 0 ||
	      ! rpwd) {
	    result->status = Q_EPERM;
	    return 1;
	  }
	  name = pwd->pw_name;
	} else {
	  if (getgrgid_r(id, grp, pwdbuf, sizeof(pwdbuf), &rgrp) != 0 ||
	      ! rgrp) {
	    result->status = Q_EPERM;
	    return 1;
	  }
	  name = grp->gr_name;
	}

	// libzfs opens

	libh = libzfs_init();
	if (!libh) {
	  fprintf(stderr, "can't open zfs library\n");
	  return 0;
	}
	zh = zfs_open(libh, filesys, ZFS_TYPE_FILESYSTEM);
	if (!zh) {
	  fprintf(stderr, "can't open file systen %s\n", filesys);
	  return 0;
	}

	// get the actual quotas

	if (type == USRQUOTA) {
	  currspace = getquota("userused", propbuf, sizeof(propbuf)-1, name, libh, zh, &failed);
	  if (!failed)
	    currfiles = getquota("userobjused", propbuf, sizeof(propbuf)-1, name, libh, zh, &failed);	  
	  if (!failed)
	    quotaspace= getquota("userquota", propbuf, sizeof(propbuf)-1, name, libh, zh, &failed);	  
	  if (!failed)
	    quotafiles= getquota("userobjquota", propbuf, sizeof(propbuf)-1, name, libh, zh, &failed);	  
	} else {
	  currspace = getquota("groupused", propbuf, sizeof(propbuf)-1, name, libh, zh, &failed);
	  if (!failed)
	    currfiles = getquota("groupobjused", propbuf, sizeof(propbuf)-1, name, libh, zh, &failed);	  
	  if (!failed)
	    quotaspace= getquota("groupquota", propbuf, sizeof(propbuf)-1, name, libh, zh, &failed);	  
	  if (!failed)
	    quotafiles= getquota("groupobjquota", propbuf, sizeof(propbuf)-1, name, libh, zh, &failed);	  
	}	  

	zfs_close(zh);
	libzfs_fini(libh);
	
	if (failed)
	  return 0;

	// return the info

	result->status = Q_OK;
        result->getquota_rslt_u.gqr_rquota.rq_active = TRUE;
	result->getquota_rslt_u.gqr_rquota.rq_bsize = 1024;
	result->getquota_rslt_u.gqr_rquota.rq_bsize = 1024;
	result->getquota_rslt_u.gqr_rquota.rq_bhardlimit = quotaspace / 1024;
	result->getquota_rslt_u.gqr_rquota.rq_bsoftlimit = quotaspace / 1024;
	result->getquota_rslt_u.gqr_rquota.rq_curblocks = currspace / 1024;
	result->getquota_rslt_u.gqr_rquota.rq_fhardlimit = quotafiles;
	result->getquota_rslt_u.gqr_rquota.rq_fsoftlimit = quotafiles;
	result->getquota_rslt_u.gqr_rquota.rq_curfiles = currfiles;
	result->getquota_rslt_u.gqr_rquota.rq_btimeleft = 0;
	result->getquota_rslt_u.gqr_rquota.rq_ftimeleft = 0;

	return 1;
}  

// Rutgers end

// Rutgers note: I've added = 0 to things we don't implement

bool_t
rquotaproc_getquota_1_svc(getquota_args arg1, getquota_rslt *result,  struct svc_req *rqstp)
{
	bool_t retval;
	// Rutgers start
	char pathname[PATH_MAX];
	uid_t id;
	int type;

	id = getpath(arg1, rqstp, pathname, &type);
	return rquotaproc_common(pathname, rqstp, result, id, type);
	// Rutgers end

	return 1;
}

bool_t
rquotaproc_getactivequota_1_svc(getquota_args arg1, getquota_rslt *result,  struct svc_req *rqstp)
{
	bool_t retval;
	// Rutgers start
	char pathname[PATH_MAX];
	uid_t id;
	int type;
	
	id = getpath(arg1, rqstp, pathname, &type);

	return rquotaproc_common(pathname, rqstp, result, id, type);
	// Rutgers end

	return retval;
}

bool_t
rquotaproc_setquota_1_svc(setquota_args arg1, setquota_rslt *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
rquotaproc_setactivequota_1_svc(setquota_args arg1, setquota_rslt *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	/*
	 * insert server code here
	 */

	return retval;
}

int
rquotaprog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}

bool_t
rquotaproc_getquota_2_svc(ext_getquota_args arg1, getquota_rslt *result,  struct svc_req *rqstp)
{
	bool_t retval;
	// Rutgers start
	char pathname[PATH_MAX];
	uid_t id;
	int type;

	id = getpath2(arg1, rqstp, pathname, &type);

	return rquotaproc_common(pathname, rqstp, result, id, type);
	// Rutgers end

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
rquotaproc_getactivequota_2_svc(ext_getquota_args arg1, getquota_rslt *result,  struct svc_req *rqstp)
{
	bool_t retval;
	// Rutgers start
	char pathname[PATH_MAX];
	uid_t id;
	int type;

	id = getpath2(arg1, rqstp, pathname, &type);

	return rquotaproc_common(pathname, rqstp, result, id, type);
	// Rutgers end

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
rquotaproc_setquota_2_svc(ext_setquota_args arg1, setquota_rslt *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t
rquotaproc_setactivequota_2_svc(ext_setquota_args arg1, setquota_rslt *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	/*
	 * insert server code here
	 */

	return retval;
}

int
rquotaprog_2_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
